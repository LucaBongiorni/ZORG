/**
 * ZRTP.org is a ZRTP protocol implementation  
 * Copyright (C) 2012 - PrivateWave Italia S.p.A.
 * 
 * This  program  is free software:  you can  redistribute it and/or
 * modify  it  under  the terms  of  the  GNU Affero  General Public
 * License  as  published  by the  Free Software Foundation,  either 
 * version 3 of the License,  or (at your option) any later version.
 * 
 * This program is  distributed in  the hope that it will be useful,
 * but WITHOUT ANY WARRANTY;  without even  the implied  warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
 * Affero General Public License for more details.
 * 
 * You should have received a copy of the  GNU Affero General Public
 * License along with this program.
 * If not, see <http://www.gnu.org/licenses/>.
 * 
 * For more information, please contact PrivateWave Italia S.p.A. at
 * address zorg@privatewave.com or http://www.privatewave.com 
 */
package zorg.platform.blackberry;

import net.rim.device.api.crypto.FIPS186PseudoRandomSource;
import net.rim.device.api.crypto.RandomSource;

/**
 * Random number generator that uses a FIPS186 Pseudo Random Source and can be
 * seeded by recorded audio samples. If no audio sample are provided it gets seeded
 * by a 64 byte key generated by net.rim.device.api.crypto.RandomSource. In case
 * of any error/exception it falls back to RandomSource when generating random
 * numbers.
 */
public class BBRandomGenerator implements zorg.platform.RandomGenerator {

    private static BBRandomGenerator instance;
    private static FIPS186PseudoRandomSource fipsGenerator = null;
	private boolean initialized = false;
    

    private BBRandomGenerator() {
        instance = this;
        seed();
    }

    public static BBRandomGenerator getInstance() {
        if (instance == null) {
            new BBRandomGenerator();
        }
        return instance;
    }

    private void seed() {
        seed(RandomSource.getBytes(64));
    }

    /**
     * Seed the random generator with 2 least significant bits of randomly picked
     * bytes within the provided PCM audio data
     *
     * @param data PCM audio data
     */
    public void seedUsingPcmAudio(byte[] data) {
        byte[] key = new byte[64];
        for (int i = 0; i < key.length; i++) {
            int x = 0;
            //Pick 4 random bytes from the PCM audio data, from each of the bytes 
            //take the two least significant bits and concatenate them to form
            //the i-th byte in the seed key
            for (int j = 0; j < 4; j++) {
                x = (x << 2) | (3 & data[RandomSource.getInt(data.length)]);
            }
            key[i] = (byte) x;
        }
        seed(key);
        initialized = true;
    }

    /**
     * Seed the random generator with a standard 20 to 64 byte byte array.
     *
     * @param key The seed key to use. Note that seed.length must be between 20
     * and 64 bytes.
     */
    private void seed(byte[] key) {
        fipsGenerator = new FIPS186PseudoRandomSource(key);
    }

    /**
     * Returns a random integer
     *
     * @return A random value of type int
     */
    public int getInt() {
        try {
            byte[] rand = fipsGenerator.getBytes(4);
            int result = rand[0];
            for (int i = 1; i < 4; i++) {
                result = (result << 8) | rand[i];
            }
            return result;
        } catch (Throwable ex) {
        	BBPlatform.getPlatform().getLogger().logException("RandomGenerator.getInt() Falling back to RandomSource " + ex.getMessage());
            return RandomSource.getInt();
        }
    }

    /**
     * Generates random bytes filling the given buffer entirely
     * 
     * @param buffer The byte array to fill with random bytes
     */
    public void getBytes(byte[] buffer) {
        try {
            fipsGenerator.getBytes(buffer);
        } catch (Throwable ex) {
        	BBPlatform.getPlatform().getLogger().logException("RandomGenerator.getBytes() Falling back to RandomSource... " + ex.getMessage());
            RandomSource.getBytes(buffer);
        }
    }

    /**
     * Generate a specified length of random bytes, returning them as a byte
     * array of the specified size
     *
     * @param length The number of random bytes to generate
     * @return A byte array containing the random bytes
     */
    public byte[] getBytes(int length) {
        try {
            return fipsGenerator.getBytes(length);
        } catch (Throwable ex) {
        	BBPlatform.getPlatform().getLogger().logException("RandomGenerator.getBytes(int) Falling back to RandomSource... " + ex.getMessage());
            return RandomSource.getBytes(length);
        }
    }

    /**
     * Inserts random bytes into the given buffer starting at the specified 
     * array index offset
     * 
     * @param buffer The buffer to store the random bytes
     * @param offset The start, or initial position, of the data within the buffer
     * @param length The number of random bytes to store

     */
    public void getBytes(byte[] buffer, int offset, int length) {
        try {
            fipsGenerator.getBytes(buffer, offset, length);
        } catch (Throwable ex) {
        	BBPlatform.getPlatform().getLogger().logException("RandomGenerator.getBytes(int, int, int) Falling back to RandomSource... " + ex.getMessage());
            RandomSource.getBytes(buffer, offset, length);
        }
    }

	public byte getByte() {
	    return getBytes(1)[0];
    }

	public boolean isInitialized() {
		return initialized;
	}
}
